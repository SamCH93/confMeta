% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hMeanChiSqCI.R
\name{hMeanChiSqCI}
\alias{hMeanChiSqCI}
\title{Calculate confidence intervals based on the harmonic mean chi-squared test}
\usage{
hMeanChiSqCI(
  thetahat,
  se,
  level = 0.95,
  alternative = "none",
  wGamma = rep(1, length(unique(thetahat)) - 1),
  check_inputs = TRUE,
  pValueFUN = hMeanChiSqMu,
  pValueFUN_args
)
}
\arguments{
\item{thetahat}{Numeric vector of parameter estimates.}

\item{se}{Numeric vector of standard errors.}

\item{level}{Numeric vector of length 1 specifying the level of the
confidence interval. Defaults to 0.95.}

\item{alternative}{Either \code{"greater"}, \code{"less"}, \code{"two.sided"}, or \code{"none"} (default).
Specifies the alternative to be considered in the computation of the p-value.}

\item{wGamma}{Numeric vector of length \code{unique(thetahat) - 1} specifying
weights used to
summarize the gamma values, i.e., the local minima of the p-value function
between the thetahats. Default is a vector of 1s.}

\item{check_inputs}{Either \code{TRUE} (default) or \code{FALSE}. Indicates whether or not to check the input arguments.
The idea of this argument is that if the function is called a large amount of times in an automated manner as for example
in simulations, performance might be increased by not checking inputs in every single iteration. However, setting the argument
to \code{FALSE} might be dangerous.}

\item{pValueFUN}{A function that calculates the p-value. Must have arguments
\code{thetahat} and \code{se} as these are passed by this function.
Must further have an argument \code{mu} that specifies the null-hypothesis.
Defaults to \code{\link[hMean]{hMeanChiSqMu}}.}

\item{pValueFUN_args}{A named \code{list} with arguments passed to
\code{pValueFUN}. This list should contain all arguments of \code{pValueFUN}
that do not have a default. Arguments \code{thetahat}, \code{se}, and
\code{mu} are automatically passed to \code{pValueFUN} and must thus not be
included in this list.}
}
\value{
Returns a list containing confidence interval(s)
obtained by inverting the harmonic mean chi-squared test based on
study-specific estimates and standard errors. The list contains:
\item{CI}{Confidence interval(s).}\cr\cr
If the \code{alternative} is "none", the list also contains:
\item{gamma}{Local minima of the p-value function between the thetahats.}
\item{gammaMean}{Mean of all gammas weighted by \code{wGamma}.}
\item{gammaHMean}{Harmonic mean of all gammas weighted by \code{wGamma}.}
}
\description{
Calculate confidence intervals based on the harmonic mean chi-squared test
}
\examples{
n <- 15
mean <- 0
sd <- 1.1
shape <- 5
rate <- 5
thetahat <- rnorm(n, mean = mean, sd = sd)
se <- rgamma(n, shape = shape, rate = rate)
heterogeneity <- "none"
phi <- if (heterogeneity == "multiplicative") {
    estimatePhi(thetahat = thetahat, se = se)
} else {
    NULL
}
tau2 <- if (heterogeneity == "additive") {
    estimateTau2(thetahat = thetahat, se = se)
} else {
    NULL
}
mu <- seq(
  min(thetahat) - 0.5 * max(se),
  max(thetahat) + 0.5 * max(se),
  length.out = 1e5
)
alpha <- 0.05
funs <- list(
    "pearson" = hMean::pPearsonMu,
    "hMean" = hMean::hMeanChiSqMu,
    "k-Trials" = hMean::kTRMu,
    "edgington" = hMean::pEdgingtonMu,
    "fisher" = hMean::pFisherMu
)
p_vals <- do.call(
    "cbind",
    lapply(
        funs,
        function(f) {
            f(
                thetahat = thetahat,
                mu = mu,
                se = se,
                heterogeneity = heterogeneity,
                phi = phi,
                tau2 = tau2,
                check_inputs = FALSE
            )
        }
    )
)
cis <- lapply(
    funs,
    function(f) {
        hMeanChiSqCI(
            thetahat = thetahat,
            se = se,
            level = 1 - alpha,
            alternative = "none",
            pValueFUN = f,
            pValueFUN_args = list(
                check_inputs = FALSE,
                heterogeneity = heterogeneity,
                phi = phi,
                tau2 = tau2
            )
        )
    }
)
plot_res <- function(
    mu,
    p_vals,
    cis = NULL,
    barheight = 0.05
) {
    opar <- par(no.readonly = TRUE)
    par(las = 1)
    matplot(
        mu,
        p_vals,
        type = "l", lty = 1, lwd = 3,
        ylab = "p-value function", xlab = expression(mu)
    )
    legend("topleft",
        col = c(1, 2, 3, 4),
        lwd = 3,
        lty = 1,
        legend = c("Pearson", "hMean", "k-Trials", "Edgington", "Fisher"),
        bty = "n",
        cex = 2
    )
    abline(h = 0.05, lty = 2)
    if (!is.null(cis)) {
        cis <- lapply(cis, "[[", i = "CI")
        jitter_inc <- 0.001
        jitter <- jitter_inc
        for (j in seq_along(cis)) {
            x <- cis[[j]]
            y_horiz <- alpha + (-1)^j * jitter
            if (j \%\% 2 == 0L) jitter <- jitter + jitter_inc
            for (i in seq_len(nrow(x))) {
                l <- x[i, "lower"]
                u <- x[i, "upper"]
                lty <- 1
                lwd <- 2
                segments( # horizontal
                    x0 = l,
                    x1 = u,
                    y0 = y_horiz,
                    y1 = y_horiz,
                    lty = lty,
                    lwd = lwd,
                    col = j
                )
                segments( # error bar left
                    x0 = l,
                    x1 = l,
                    y0 = y_horiz - barheight / 2,
                    y1 = y_horiz + barheight / 2,
                    lty = lty,
                    lwd = lwd,
                    col = j
                )
                segments( # error bar left
                    x0 = u,
                    x1 = u,
                    y0 = y_horiz - barheight / 2,
                    y1 = y_horiz + barheight / 2,
                    lty = lty,
                    lwd = lwd,
                    col = j
                )
            }
        }
    }
    par(opar)
}
plot_res(mu = mu, p_vals = p_vals, cis = cis)

}
