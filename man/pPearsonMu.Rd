% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pearson.R
\name{pPearsonMu}
\alias{pPearsonMu}
\title{p-Value of Pearson combination test}
\usage{
pPearsonMu(
  thetahat,
  se,
  mu,
  phi = NULL,
  tau2 = NULL,
  alternative = "none",
  heterogeneity = c("none", "additive", "multiplicative")
)
}
\arguments{
\item{thetahat}{Numeric vector of parameter estimates.}

\item{se}{Numeric vector of standard errors.}

\item{mu}{A numeric vector containing null hypothesis value(s).}

\item{phi}{A numeric vector of length 1. Must be finite and larger than 0. The square root of the argument is used to scale the standard errors.}

\item{tau2}{A numeric vector of length 1.}

\item{alternative}{Either \code{"greater"}, \code{"less"}, \code{"two.sided"}, or \code{"none"} (default).
Specifies the alternative to be considered in the computation of the p-value.}

\item{heterogeneity}{One of \code{c("none", "additive", "multiplicative")}. If \code{heterogeneity = "none"} p-values are returned for the
passed \code{se} without any adaption. If \code{heterogeneity = "additive"}, the standard errors \code{se} are reassigned the value of \code{sqrt(se^2 + tau2)} before
computation of the p-values. If \code{heterogeneity = "multiplicative"}, the standard errors \code{se} are multiplied with the value of \code{phi} before
computation of the p-values. Defaults to \code{"none"}.}

\item{check_inputs}{Either \code{TRUE} (default) or \code{FALSE}. Indicates whether or not to check the input arguments.
The idea of this argument is that if the function is called a large amount of times in an automated manner as for example
in simulations, performance might be increased by not checking inputs in every single iteration. However, setting the argument
to \code{FALSE} might be dangerous.}
}
\value{
The corresponding p-value given mu under the null-hypothesis.
}
\description{
p-Value of Pearson combination test
}
\examples{
resP <- resH <- resTR <- numeric()
n <- 15
thetahat <- rnorm(n)
se <- rgamma(n, 5, 5)
mu <- seq(
  min(thetahat) - 0.5 * max(se),
  max(thetahat) + 0.5 * max(se),
  length.out = 1e4
)
phi <- estimatePhi(thetahat = thetahat, se = se)
for(i in 1:length(mu)){
  resP[i] <- pPearsonMu(
    thetahat=thetahat,
    se=se,
    mu=mu[i],
    heterogeneity="multiplicative",
    phi=phi
  )
  resH[i] <- hMeanChiSqMu(
    thetahat=thetahat,
    se = se,
    mu = mu[i],
    heterogeneity = "multiplicative",
    phi = phi
  )
  resTR[i] <- kTRMu(
    thetahat = thetahat,
    se = se,
    mu = mu[i],
    heterogeneity = "multiplicative",
    phi = phi
  )
}
par(las=1)
matplot(
  mu,
  cbind(resP, resH, resTR),
  type = "l",
  lty = 1,
  lwd = 2,
  ylab = "p-value function"
)
legend("topleft", col=c(1,2,3), lwd=2, lty=1, c("Pearson", "hMean","kTR"))
title(paste("Phi =", as.character(round(phi, 2))))
}
