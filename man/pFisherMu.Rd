% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fisher.R
\name{pFisherMu}
\alias{pFisherMu}
\title{Calculate the p-value using the Fisher test.}
\usage{
pFisherMu(
  thetahat,
  se,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  check_inputs = TRUE
)
}
\arguments{
\item{thetahat}{Numeric vector of parameter estimates.}

\item{se}{Numeric vector of standard errors.}

\item{mu}{A numeric vector containing null hypothesis value(s).}

\item{phi}{A numeric vector of length 1. Must be finite and larger than 0. The square root of the argument is used to scale the standard errors.}

\item{tau2}{A numeric vector of length 1.}

\item{heterogeneity}{One of \code{c("none", "additive", "multiplicative")}. If \code{heterogeneity = "none"} p-values are returned for the
passed \code{se} without any adaption. If \code{heterogeneity = "additive"}, the standard errors \code{se} are reassigned the value of \code{sqrt(se^2 + tau2)} before
computation of the p-values. If \code{heterogeneity = "multiplicative"}, the standard errors \code{se} are multiplied with the value of \code{phi} before
computation of the p-values. Defaults to \code{"none"}.}

\item{check_inputs}{Either \code{TRUE} (default) or \code{FALSE}. Indicates whether or not to check the input arguments.
The idea of this argument is that if the function is called a large amount of times in an automated manner as for example
in simulations, performance might be increased by not checking inputs in every single iteration. However, setting the argument
to \code{FALSE} might be dangerous.}
}
\value{
The corresponding p-values given mu under the null-hypothesis.
}
\description{
Calculate the p-value using the Fisher test.
}
\details{
The function is is vectorized over the \code{mu} argument.
}
\examples{
n <- 15
thetahat <- rnorm(n)
se <- rgamma(n, 5, 5)
mu <- seq(
  min(thetahat) - 0.5 * max(se),
  max(thetahat) + 0.5 * max(se),
  length.out = 1e5
)
heterogeneity <- "multiplicative"
phi <- estimatePhi(thetahat = thetahat, se = se)
resP <- pPearsonMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
resH <- hMeanChiSqMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
resTR <- kTRMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
resE <- pEdgingtonMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
resF <- pFisherMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
par(las = 1)
matplot(
  mu,
  cbind(resP, resH, resTR, resE, resF),
  type = "l",
  lty = 1,
  lwd = 3,
  ylab = "p-value function"
)
legend("topleft",
  col = 1:5,
  lwd = 3,
  lty = 1,
  c("Pearson", "hMean", "kTR", "Edgington", "Fisher")
)
title(paste("Phi =", as.character(round(phi, 2))))

}
