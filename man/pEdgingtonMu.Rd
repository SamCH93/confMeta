% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/edgington.R
\name{pEdgingtonMu}
\alias{pEdgingtonMu}
\title{Calculate the p-value using the Pearson combination test.}
\usage{
pEdgingtonMu(
  thetahat,
  se,
  mu = 0,
  phi = NULL,
  tau2 = NULL,
  heterogeneity = "none",
  alternative = "two.sided",
  check_inputs = TRUE,
  approx = TRUE
)
}
\arguments{
\item{thetahat}{Numeric vector of parameter estimates.}

\item{se}{Numeric vector of standard errors.}

\item{mu}{A numeric vector containing null hypothesis value(s).}

\item{phi}{A numeric vector of length 1. Must be finite and larger than 0. The square root of the argument is used to scale the standard errors.}

\item{tau2}{A numeric vector of length 1.}

\item{heterogeneity}{One of \code{c("none", "additive", "multiplicative")}. If \code{heterogeneity = "none"} p-values are returned for the
passed \code{se} without any adaption. If \code{heterogeneity = "additive"}, the standard errors \code{se} are reassigned the value of \code{sqrt(se^2 + tau2)} before
computation of the p-values. If \code{heterogeneity = "multiplicative"}, the standard errors \code{se} are multiplied with the value of \code{phi} before
computation of the p-values. Defaults to \code{"none"}.}

\item{alternative}{Either \code{"greater"}, \code{"less"}, \code{"two.sided"}, or \code{"none"} (default).
Specifies the alternative to be considered in the computation of the p-value.}

\item{check_inputs}{Either \code{TRUE} (default) or \code{FALSE}. Indicates whether or not to check the input arguments.
The idea of this argument is that if the function is called a large amount of times in an automated manner as for example
in simulations, performance might be increased by not checking inputs in every single iteration. However, setting the argument
to \code{FALSE} might be dangerous.}

\item{approx}{Must be either TRUE (default) or FALSE. If TRUE, the p-value
is computed using the normal approximation of the exact Irwin-Hall
distribution if \code{length(thetahat) >= 12}. This avoids issues that can
lead to overflow of the double precision floating point numbers R uses for
numeric vectors.}
}
\value{
The corresponding p-values given mu under the null-hypothesis.
}
\description{
Calculate the p-value using the Pearson combination test.
}
\details{
The function is is vectorized over the \code{mu} argument.
}
\examples{
n <- 15
thetahat <- rnorm(n)
se <- rgamma(n, 5, 5)
mu <- seq(
  min(thetahat) - 0.5 * max(se),
  max(thetahat) + 0.5 * max(se),
  length.out = 1e5
)
heterogeneity <- "multiplicative"
phi <- estimatePhi(thetahat = thetahat, se = se)
resP <- pPearsonMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
resH <- hMeanChiSqMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
resTR <- kTRMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
resE <- pEdgingtonMu(
    thetahat = thetahat,
    se = se,
    mu = mu,
    heterogeneity = heterogeneity,
    phi = phi
)
par(las = 1)
matplot(
  mu,
  cbind(resP, resH, resTR, resE),
  type = "l",
  lty = 1,
  lwd = 2,
  ylab = "p-value function"
)
legend("topleft",
  col=c(1, 2, 3, 4),
  lwd=2,
  lty=1,
  c("Pearson", "hMean","kTR","Edgington")
)
title(paste("Phi =", as.character(round(phi, 2))))
}
